# -*- coding: utf-8 -*-
"""Python_Course.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-50u54-n15s6D3nXAB3I6YQ5LS-zBBCQ

# **Hands on Python in Finance**

This course provides a comprehensive exploration of the intersection between finance and computer science, with a specific focus on leveraging Python for financial analysis and applications.

Throughout the course, practical examples are presented, all of which are derived from an online educational platform called Mind Luster. If you are interested, you can access the course through this [Hands on Python in Finance](https://https://www.mindluster.com/certificate/7505).

It's important to note that the numerical values used in the course are arbitrary and can be substituted with any other values as per your preference. The values presented were originally utilized by the course instructor for illustrative purposes, but you are free to replace them with your own data for experimentation and learning.

# **Lecture 1**
## **Numpy Library in Python**
"""

# By convention, we import numpy in our program as np
import numpy as np

# A one dimensional array
arr_1d = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
arr_1d

# A two dimensional array
arr_2d = np.array([[1, 2, 3], [4, 5, 6]])
arr_2d

# Print the dimensions of the array
print("The dimensions of 1d array are:", np.ndim(arr_1d))
print("The dimensions of 2d array are:", np.ndim(arr_2d))

# Size of the arrays
print("The size of 1d array is:", np.size(arr_1d))
print("The size of 2d array is:", np.size(arr_2d))

# Shape of arrays
print("Shape of 1d array:", np.shape(arr_1d))
print("Shape of 2d array:", np.shape(arr_2d))

# Generating an array with sequential data in it
np_range = np.array(range(15))
np_arrange = np.array(np.arange(15))
print(np_range)
print(np_arrange)

# Determine the data type
np_arrange.dtype

# Recasting datatype
np_arrange = np.array(np_arrange, dtype = "float64")
np_arrange

# Reshape the data
arr_temp = np.arange(15).reshape(3, 5)
arr_temp

# Transpose the array
arr_temp.T

# Assigning values
arr_temp[1,1] = 100
arr_temp

# Subsetting data
arr_temp[::3]

"""# **Lecture 2**
## **Present Value**
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
# %matplotlib inline

# Basic Example to get you started
futureValue = 50000   # in dollars
rate = 0.05
time = 1              # in years
presentValue = futureValue / ((1 + rate)**time)
print(round(presentValue, 2))

# By making a function for the above
def presentValue(futureValue, rate, time):
  return round(futureValue / ((1 + rate)**time), 2)

# Now call the function
time = 5    # assume time is now 5 years to get to $50000
presentValue(futureValue, rate, time)

# Another example, winning a lottery
cashFlow = np.ones(20) * 50000
size = cashFlow.size
for year in range(size):
  cashFlow[year] = round(cashFlow[year] / (1 + rate) ** year, 1)

# Print the arryay
cashFlow

plt.plot(cashFlow)
plt.title("Money vs Time")
plt.grid(linestyle = "-")
plt.xticks([0, 5, 10, 15, 20])

# Sums the values in cashFlow array to keep in record the values wew get over the time
sum(cashFlow)

"""# **Lecture 3**
## **Opening and Reading .CSV File**

### **Using with open function**
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import csv
# %matplotlib inline

from google.colab import drive
drive.mount('/content/drive')

# Specify the file path of the CSV file in your Google Drive
file_path = '/content/drive/MyDrive/data/file.csv'

# Read the CSV file using the with open() function
data = []
with open(file_path, 'r') as csvfile:
    for line in csvfile:
        data.append(line.strip().split(','))

# Display the data on the screen
for row in data:
    print(row)

# Print the first row
data[1]

import numpy as np
data_array = np.array(data)

"""### **Using Pandas Dataframe**"""

import pandas as pd
file_path = '/content/drive/MyDrive/data/file.csv'
data_pd = pd.read_csv(file_path)
data_pd.head()

# Plot a graph for Cr.Attp column in the csv file
data_pd['Cr. Attp'].plot()

"""# **Lecture 4**
## **Valuing Securities**
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline

# Expected return
dividend = 2.92
stock_worth_now = 152.60
stock_worth_later = 178.71
expected_return = (dividend + stock_worth_later) / stock_worth_now
print("Expected Result: {}".format(expected_return - 1))

present_value = (dividend + stock_worth_later) / expected_return
print("Current value: {}".format(present_value))

# Dividend Discount Model
growth = 0.08
expected_return = 0.12
stock_worth_later = 81
dividend = 3
horizon = pd.DataFrame({'dividend' : np.zeros(3), 'expected_price' : np.zeros(3)})
horizon.index = np.arange(1, len(horizon) + 1)
horizon.index.name = 'Year'
for year in range(1, horizon['dividend'].count() + 1):
  if year == 1:
    horizon['dividend'][year] = dividend
    horizon['expected_price'][year] = stock_worth_later
  else:
    horizon['dividend'][year] = dividend * (1 + growth) ** (year - 1)
    horizon['expected_price'][year] = stock_worth_later * (1 + growth) ** (year - 1)

horizon

# Check what the stock will be be worth now
(horizon['dividend'][1] + horizon['expected_price'][1]) / (1 + expected_return)

# Check what the stock will be be worth in two years from now
(horizon['dividend'][1] + horizon['expected_price'][1] / (1 + expected_return) + (horizon['dividend'][2] + horizon['expected_price'][2]) / (1 + expected_return) ** 2)

# Check what the stock will be worth in another year
horizon['dividend'][1] / (1 + expected_return) + ((horizon['dividend'][2] + horizon['expected_price'][2]) / (1 + expected_return) ** 2)

# Constant growth model
dividend = 3
growth = 0.08
expected_return = 0.12
dividend / (expected_return - growth)

# Stocks with no dividend
earning_per_share = 5.60
expected_return = 0.12
pe = 15

earning_per_share * pe / (1 + expected_return)

# Actual earning what I get from that particular share
earning_actual = 5.30
earning_actual * 14 / ( 1 + expected_return)

"""# **Lecture 5**
# **Introduction to Monte Carlo Method and Building a Monte Carlo Simulation App**

It is used to model the ***probability of different outcomes*** in a process that cannot easily be predicted due to the intervention of random variables.

"""

present_value = 100000
expected_return = 0.095
time_horizon = 30
ending_balance = 0

# Deterministic Method
print("{:10s} {:15s}".format("Year", "Ending Balance"))
print("-" * 26)
for year in range(1, time_horizon + 1):
  ending_balance = present_value *  (1 + expected_return)
  print("{:<10d} {:15,.0f}".format(year, ending_balance))
  present_value = ending_balance

# We can't get 9.5% each year, thus we introduce some volataility
# It depends on the inflation. As stated in the course, we have chosen 0.185/
# We can choose any other value as well
volatility = 0.185

import numpy.random as npr    # Just import random module

present_value = 100000
expected_return = 0.095
time_horizon = 30
ending_balance = 0

print("{:10s} {:15s}".format("Year", "Ending Balance"))
print("-" * 26)
for year in range(1, time_horizon + 1):
  year_return = npr.normal(expected_return, volatility)
  ending_balance = present_value *  (1 + year_return)
  print("{:<10d} {:>15,.0f}".format(year, ending_balance))
  present_value = ending_balance